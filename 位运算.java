package test;

/**
 * 位运算 补码 0x0F 的意义 
 * byte 字节型 8个字节 最前面一个是符号位 座椅 最大数是 0111 1111  也就是 127
 * ＋8的补码，原码，反码，都是 0000 1000。
 * 求一个负数的补码: 先去他的绝对值,再取反,+1 就是 他的补码 比如 -8 实际上我们认识的是这样,10001000
 * 负数的补码，原码，反码都是用1放在符号位，后面7位有变化：
－8的原码：1000 1000；
－8的反码：1111 0111；
－8的补码：1111 1000。  
 * 他在计算机中存储的补码 应该是这样: 10001000(-8) 取反: 11110111  +1 -->最终存储的就是这样11111000
 0b 开头是二进制
0开头是8进制
0x开头是16进制
 */
public class test {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
        int[] arr =new int[]{8,2,1,0,3};
        int[] index =new int[]{2,0,3,2,4,0,1,3,2,3,3};
        String tel ="";
        for(int i :index){
        	tel+=arr[i];
        }
		byte b =(byte) 130;
		System.out.println(b);
		int a =b >=0?b:256+b;
		int c =b &0xff;//将B转换成无符号型进行&运算
		System.out.println(c);
        int b =4 ,a, c;
        for(int i=0;i<10;i++){ 
        	b=22 | 1;//  或   运算 转换成二进制，只要有一个为1  都为1   
        }            // 0001 0110 
        			 // 0000 0001           // 0001 0111
         a=22 & 1;   // 与   运算   只有两个都为1   才为1 
         c=22^1;     //  异或 运算 相同结果为0，不同结果为1
         c =~23;      // 非   0为1  1为0   00010111  11101000 首位为1 越界了成负数      00010111 +1 
         			//计算机中数据的存储方式是以他的补码形式存在的   负数的补码是 取反 再加1 
        System.out.println("联系方式: "+ c);                
	}

}
